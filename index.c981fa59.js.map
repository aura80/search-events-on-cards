{"mappings":"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","sources":["<anon>","src/script.js"],"sourcesContent":["document.addEventListener(\"DOMContentLoaded\", function() {\n    const serverUrl = \"http://localhost:3000/events\"; // URL-ul serverului local\n    const searchButton = document.getElementById(\"searchButton\");\n    const searchInput = document.getElementById(\"searchInput\");\n    const eventContainer = document.getElementById(\"eventContainer\");\n    const modalEventName = document.getElementById(\"modalEventName\");\n    const paginationContainer = document.getElementById(\"paginationContainer\");\n    const span = document.getElementsByClassName(\"close\")[0];\n    const modal = document.getElementById(\"myModal\");\n    const eventsPerPage = 20;\n    let currentPage = 1;\n    // Set background color for main page\n    document.body.style.backgroundColor = \"black\";\n    // Fetch initial events when the page loads\n    fetchEvents(serverUrl, eventsPerPage, currentPage);\n    // Event listener for the search button\n    searchButton.addEventListener(\"click\", function() {\n        const searchTerm = searchInput.value;\n        console.log(\"Search Term:\", searchTerm);\n        if (searchTerm) {\n            currentPage = 1; // Reset to first page on search\n            fetchEvents(serverUrl, eventsPerPage, currentPage, searchTerm);\n        } else alert(\"Please enter an event name to search\");\n    });\n    // Deschide modalul\n    eventContainer.addEventListener(\"click\", function(event) {\n        const target = event.target.closest(\".event-card\");\n        target.style.zIndex = \"2\";\n        console.log(\"Modal: \", target.name);\n        if (target) {\n            modal.style.display = \"block\";\n            modal.style.zIndex = \"3\";\n            modalEventName.textContent = target.dataset.name;\n        }\n    });\n    // Închide modalul\n    span.onclick = function() {\n        modal.style.display = \"none\";\n    };\n    window.onclick = function(event) {\n        if (event.target == modal) modal.style.display = \"none\";\n    };\n    // ? ultima care parea buna\n    function fetchEvents(url, size, page, searchTerm = \"\") {\n        const paginatedUrl = `${url}?size=${size}&page=${page - 1}${searchTerm ? `&keyword=${searchTerm}` : \"\"}`;\n        console.log(\"Fetching events from URL:\", paginatedUrl);\n        fetch(paginatedUrl).then((response)=>{\n            console.log(\"Raw response:\", response); // Log pentru răspuns brut\n            if (!response.ok) {\n                console.error(`HTTP error! Status: ${response.status} - ${response.statusText}`); // Log pentru codul de eroare\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.json();\n        }).then((data)=>{\n            console.log(\"Events fetched:\", data); // Log pentru verificare a răspunsului\n            if (data._embedded && data._embedded.events) {\n                eventContainer.innerHTML = \"\"; // Golește conținutul anterior\n                paginationContainer.innerHTML = \"\"; // Golește navigarea între pagini\n                const events = data._embedded.events.filter(isValidEvent);\n                console.log(\"Valid events to be processed:\", events);\n                populateEvents(events);\n                const totalPages = Math.min(30, Math.ceil(data.page.totalElements / size)); // Limitează numărul total de pagini la 30\n                createPagination(totalPages, page, searchTerm);\n            } else {\n                console.error(\"No events found in the response\");\n                eventContainer.innerHTML = \"<p>No events found.</p>\";\n                eventContainer.style.color = \"white\";\n                eventContainer.style.fontSize = \"30px\";\n                eventContainer.style.display = \"flex\";\n                eventContainer.style.flexDirection = \"row\";\n                eventContainer.style.justifyContent = \"center\";\n            }\n        }).catch((error)=>{\n            console.error(\"Error fetching events:\", error);\n            eventContainer.innerHTML = `<p>Error fetching events. Please try again later. ${error.message}</p>`;\n        });\n    }\n    // Funcție pentru a verifica dacă un eveniment este valid pe baza proprietăților care există întotdeauna\n    function isValidEvent(event) {\n        return event && event.name && event.url;\n    }\n    // Collect all events from all pages for search\n    function collectAllEvents(url, size, totalPages, searchTerm) {\n        let allEvents = [];\n        let requests = [];\n        for(let i = 0; i < totalPages; i++){\n            const paginatedUrl = `${url}?size=${size}&page=${i}${searchTerm ? `&keyword=${searchTerm}` : \"\"}`;\n            console.log(\"Fetching events from URL (all pages):\", paginatedUrl);\n            requests.push(fetch(paginatedUrl).then((response)=>response.json()).then((data)=>{\n                if (data._embedded && data._embedded.events) {\n                    const validEvents = data._embedded.events.filter(isValidEvent);\n                    allEvents = allEvents.concat(validEvents);\n                }\n            }).catch((error)=>{\n                console.error(`Error fetching events from page ${i}:`, error);\n            }));\n        }\n        Promise.all(requests).then(()=>{\n            eventContainer.innerHTML = \"\"; // Clear previous content\n            if (allEvents.length > 0) {\n                console.log(\"All valid events to be processed:\", allEvents);\n                populateEvents(allEvents);\n            } else eventContainer.innerHTML = \"<p>No events found.</p>\";\n        }).catch((error)=>{\n            console.error(\"Error fetching events:\", error);\n            eventContainer.innerHTML = \"<p>Error fetching events. Please try again later.</p>\";\n        });\n    }\n    function populateEvents(events) {\n        eventContainer.innerHTML = \"\"; // Clear previous content\n        events.forEach((event)=>{\n            // Log pentru verificarea fiecărui eveniment\n            console.log(\"Processing event:\", event);\n            // Verifică dacă datele există înainte de a le accesa\n            const eventName = event?.name || \"Unknown Event\";\n            const eventUrl = event?.url || \"#\";\n            // const eventStandardUrl = event?.priceRanges || \"#\"; // Asigură-te că standardUrl există\n            // Date și locație\n            const eventDate = event?.dates?.start?.dateTime ? new Date(event.dates.start.dateTime).toLocaleDateString() : \"Unknown Date\";\n            const eventLocation = event?._embedded?.venues?.[0] ? `${event._embedded.venues[0].name}, ${event._embedded.venues[0].city.name}` : \"Unknown Location\";\n            // Imaginea evenimentului\n            const eventImage = event.images && event.images[0]?.url ? event.images[0].url : \"\";\n            const eventCard = document.createElement(\"div\");\n            eventCard.classList.add(\"event-card\");\n            eventCard.dataset.name = eventName;\n            eventCard.dataset.url = eventUrl; // Store URL in data attribute\n            eventCard.style.backgroundColor = \"black\"; // Schimbă fundalul cardului în negru\n            eventCard.style.border = \"1px solid black\";\n            eventCard.style.position = \"relative\";\n            const square = document.createElement(\"div\");\n            square.classList.add(\"square\");\n            square.style.borderRadius = \"50px 0px 50px 0px\";\n            square.style.border = \"1px solid rgba(238, 30, 203, 0.3)\";\n            square.style.backgroundColor = \"transparent\";\n            square.style.position = \"absolute\";\n            square.style.top = \"0\";\n            square.style.right = \"0\";\n            square.style.width = \"80%\";\n            square.style.height = \"40%\";\n            square.style.zIndex = \"1\";\n            eventCard.appendChild(square);\n            const eventImageElem = document.createElement(\"img\");\n            eventImageElem.classList.add(\"event-image\");\n            eventImageElem.src = eventImage;\n            eventImageElem.alt = `${eventName} Image`;\n            eventImageElem.style.width = \"100%\";\n            eventImageElem.style.borderRadius = \"50px 0px 50px 0px\";\n            eventImageElem.style.position = \"relative\";\n            eventImageElem.style.zIndex = \"0\";\n            eventCard.appendChild(eventImageElem);\n            const eventNameElem = document.createElement(\"h3\");\n            eventNameElem.textContent = eventName;\n            eventNameElem.style.color = \"#DC56C5\";\n            eventCard.appendChild(eventNameElem);\n            const eventDateElem = document.createElement(\"p\");\n            eventDateElem.textContent = `${eventDate}`;\n            eventCard.appendChild(eventDateElem);\n            const eventLocationElem = document.createElement(\"p\");\n            // Creăm un container pentru imaginea vectorului și locație\n            const locationContainer = document.createElement(\"span\");\n            locationContainer.style.display = \"flex\";\n            locationContainer.style.alignItems = \"center\";\n            // Adăugăm imaginea vectorului pe aceeași linie cu locația\n            const vectorImg = document.createElement(\"img\");\n            vectorImg.src = \"../images/Vector.png\";\n            vectorImg.alt = \"Vector Image\";\n            vectorImg.style.width = \"7px\";\n            vectorImg.style.height = \"10px\";\n            vectorImg.style.marginRight = \"7px\";\n            // Adaugare la span\n            locationContainer.appendChild(vectorImg);\n            locationContainer.appendChild(document.createTextNode(eventLocation));\n            eventLocationElem.appendChild(locationContainer);\n            eventCard.appendChild(eventLocationElem);\n            // const eventUrlElem = document.createElement(\"a\");\n            // eventUrlElem.href = eventUrl;\n            // eventUrlElem.textContent = \"View Event\";\n            // eventUrlElem.target = \"_blank\";\n            // eventCard.appendChild(eventUrlElem);\n            eventContainer.appendChild(eventCard);\n            console.log(\"Event card created for event:\", eventName);\n        });\n    }\n    function createPagination(totalPages, currentPage, searchTerm = \"\") {\n        // Limitează numărul total de pagini la 30\n        totalPages = Math.min(totalPages, 30);\n        if (totalPages <= 1) return;\n        // Create the previous page button\n        if (currentPage > 1) {\n            const prevButton = document.createElement(\"button\");\n            prevButton.textContent = \"Previous\";\n            prevButton.addEventListener(\"click\", function() {\n                fetchEvents(serverUrl, eventsPerPage, currentPage - 1, searchTerm);\n            });\n            paginationContainer.appendChild(prevButton);\n        }\n        // Create page buttons with ellipses\n        for(let i = 1; i <= totalPages; i++){\n            if (i === 1 || i === totalPages || i >= currentPage - 2 && i <= currentPage + 2) {\n                const pageButton = document.createElement(\"button\");\n                pageButton.textContent = i;\n                if (i === currentPage) pageButton.style.fontWeight = \"bold\";\n                pageButton.addEventListener(\"click\", function() {\n                    fetchEvents(serverUrl, eventsPerPage, i, searchTerm);\n                });\n                paginationContainer.appendChild(pageButton);\n            } else if (i === currentPage - 3 || i === currentPage + 3) {\n                const dots = document.createElement(\"span\");\n                dots.textContent = \"...\";\n                paginationContainer.appendChild(dots);\n            }\n        }\n        // Create the next page button\n        if (currentPage < totalPages) {\n            const nextButton = document.createElement(\"button\");\n            nextButton.textContent = \"Next\";\n            nextButton.addEventListener(\"click\", function() {\n                fetchEvents(serverUrl, eventsPerPage, currentPage + 1, searchTerm);\n            });\n            paginationContainer.appendChild(nextButton);\n        }\n    }\n});\n\n//# sourceMappingURL=index.c981fa59.js.map\n","document.addEventListener(\"DOMContentLoaded\", function () {\r\n  const serverUrl = \"http://localhost:3000/events\"; // URL-ul serverului local\r\n  const searchButton = document.getElementById(\"searchButton\");\r\n  const searchInput = document.getElementById(\"searchInput\");\r\n  const eventContainer = document.getElementById(\"eventContainer\");\r\n  const modalEventName = document.getElementById(\"modalEventName\");\r\n  const paginationContainer = document.getElementById(\"paginationContainer\");\r\n  const span = document.getElementsByClassName(\"close\")[0];\r\n  const modal = document.getElementById(\"myModal\");\r\n  const eventsPerPage = 20;\r\n  let currentPage = 1;\r\n\r\n  // Set background color for main page\r\n  document.body.style.backgroundColor = \"black\";\r\n\r\n  // Fetch initial events when the page loads\r\n  fetchEvents(serverUrl, eventsPerPage, currentPage);\r\n\r\n  // Event listener for the search button\r\n  searchButton.addEventListener(\"click\", function () {\r\n    const searchTerm = searchInput.value;\r\n    console.log(\"Search Term:\", searchTerm); \r\n    if (searchTerm) {\r\n      currentPage = 1; // Reset to first page on search\r\n      fetchEvents(serverUrl, eventsPerPage, currentPage, searchTerm);\r\n    } else {\r\n      alert(\"Please enter an event name to search\");\r\n    }\r\n  });\r\n\r\n  // Deschide modalul\r\n  eventContainer.addEventListener(\"click\", function (event) {\r\n    const target = event.target.closest(\".event-card\");\r\n    target.style.zIndex = \"2\";\r\n    console.log(\"Modal: \", target.name);\r\n    if (target) {\r\n      modal.style.display = \"block\";\r\n      modal.style.zIndex = \"3\";\r\n      modalEventName.textContent = target.dataset.name;\r\n    }\r\n  });\r\n\r\n  // Închide modalul\r\n  span.onclick = function () {\r\n    modal.style.display = \"none\";\r\n  };\r\n\r\n  window.onclick = function (event) {\r\n    if (event.target == modal) {\r\n      modal.style.display = \"none\";\r\n    }\r\n  };\r\n\r\n  // ? ultima care parea buna\r\n  function fetchEvents(url, size, page, searchTerm = \"\") {\r\n    const paginatedUrl = `${url}?size=${size}&page=${page - 1}${\r\n      searchTerm ? `&keyword=${searchTerm}` : \"\"\r\n    }`;\r\n    console.log(\"Fetching events from URL:\", paginatedUrl); \r\n    fetch(paginatedUrl)\r\n      .then((response) => {\r\n        console.log(\"Raw response:\", response); // Log pentru răspuns brut\r\n        if (!response.ok) {\r\n          console.error(\r\n            `HTTP error! Status: ${response.status} - ${response.statusText}`\r\n          ); // Log pentru codul de eroare\r\n          throw new Error(`HTTP error! Status: ${response.status}`);\r\n        }\r\n\r\n        return response.json();\r\n      })\r\n      .then((data) => {\r\n        console.log(\"Events fetched:\", data); // Log pentru verificare a răspunsului\r\n        if (data._embedded && data._embedded.events) {\r\n          eventContainer.innerHTML = \"\"; // Golește conținutul anterior\r\n          paginationContainer.innerHTML = \"\"; // Golește navigarea între pagini\r\n          const events = data._embedded.events.filter(isValidEvent);\r\n          console.log(\"Valid events to be processed:\", events);\r\n          populateEvents(events);\r\n          const totalPages = Math.min(\r\n            30,\r\n            Math.ceil(data.page.totalElements / size)\r\n          ); // Limitează numărul total de pagini la 30\r\n\r\n          createPagination(totalPages, page, searchTerm);\r\n        } else {\r\n          console.error(\"No events found in the response\");\r\n          eventContainer.innerHTML = \"<p>No events found.</p>\";\r\n                  eventContainer.style.color = \"white\";\r\n                  eventContainer.style.fontSize = \"30px\";\r\n                  eventContainer.style.display = \"flex\";\r\n                  eventContainer.style.flexDirection = \"row\";\r\n                  eventContainer.style.justifyContent = \"center\";\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error fetching events:\", error);\r\n        eventContainer.innerHTML = `<p>Error fetching events. Please try again later. ${error.message}</p>`;\r\n      });\r\n  }\r\n\r\n  // Funcție pentru a verifica dacă un eveniment este valid pe baza proprietăților care există întotdeauna\r\n  function isValidEvent(event) {\r\n    return event && event.name && event.url;\r\n  }\r\n\r\n  // Collect all events from all pages for search\r\n  function collectAllEvents(url, size, totalPages, searchTerm) {\r\n    let allEvents = [];\r\n    let requests = [];\r\n\r\n    for (let i = 0; i < totalPages; i++) {\r\n      const paginatedUrl = `${url}?size=${size}&page=${i}${\r\n        searchTerm ? `&keyword=${searchTerm}` : \"\"\r\n      }`;\r\n      console.log(\"Fetching events from URL (all pages):\", paginatedUrl); \r\n      requests.push(\r\n        fetch(paginatedUrl)\r\n          .then((response) => response.json())\r\n          .then((data) => {\r\n            if (data._embedded && data._embedded.events) {\r\n              const validEvents = data._embedded.events.filter(isValidEvent);\r\n              allEvents = allEvents.concat(validEvents);\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            console.error(`Error fetching events from page ${i}:`, error);\r\n          })\r\n      );\r\n    }\r\n\r\n    Promise.all(requests)\r\n      .then(() => {\r\n        eventContainer.innerHTML = \"\"; // Clear previous content\r\n        if (allEvents.length > 0) {\r\n          console.log(\"All valid events to be processed:\", allEvents);\r\n          populateEvents(allEvents);\r\n        } else {\r\n          eventContainer.innerHTML = \"<p>No events found.</p>\";\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(\"Error fetching events:\", error);\r\n        eventContainer.innerHTML =\r\n          \"<p>Error fetching events. Please try again later.</p>\";\r\n      });\r\n  }\r\n\r\n  function populateEvents(events) {\r\n    eventContainer.innerHTML = \"\"; // Clear previous content\r\n\r\n    events.forEach((event) => {\r\n      // Log pentru verificarea fiecărui eveniment\r\n      console.log(\"Processing event:\", event);\r\n\r\n      // Verifică dacă datele există înainte de a le accesa\r\n      const eventName = event?.name || \"Unknown Event\";\r\n      const eventUrl = event?.url || \"#\";\r\n      // const eventStandardUrl = event?.priceRanges || \"#\"; // Asigură-te că standardUrl există\r\n\r\n      // Date și locație\r\n      const eventDate = event?.dates?.start?.dateTime\r\n        ? new Date(event.dates.start.dateTime).toLocaleDateString()\r\n        : \"Unknown Date\";\r\n      const eventLocation = event?._embedded?.venues?.[0]\r\n        ? `${event._embedded.venues[0].name}, ${event._embedded.venues[0].city.name}`\r\n        : \"Unknown Location\";\r\n\r\n      // Imaginea evenimentului\r\n      const eventImage =\r\n        event.images && event.images[0]?.url ? event.images[0].url : \"\";\r\n\r\n      const eventCard = document.createElement(\"div\");\r\n      eventCard.classList.add(\"event-card\");\r\n      eventCard.dataset.name = eventName;\r\n      eventCard.dataset.url = eventUrl; // Store URL in data attribute\r\n      eventCard.style.backgroundColor = \"black\"; // Schimbă fundalul cardului în negru\r\n      eventCard.style.border = \"1px solid black\";\r\n      eventCard.style.position = \"relative\";\r\n\r\n      const square = document.createElement(\"div\");\r\n      square.classList.add(\"square\");\r\n      square.style.borderRadius = \"50px 0px 50px 0px\";\r\n      square.style.border = \"1px solid rgba(238, 30, 203, 0.3)\";\r\n      square.style.backgroundColor = \"transparent\";\r\n      square.style.position = \"absolute\";\r\n      square.style.top = \"0\";\r\n      square.style.right = \"0\";\r\n      square.style.width = \"80%\";\r\n      square.style.height = \"40%\";\r\n      square.style.zIndex = \"1\";\r\n      eventCard.appendChild(square);\r\n\r\n      const eventImageElem = document.createElement(\"img\");\r\n      eventImageElem.classList.add(\"event-image\");\r\n      eventImageElem.src = eventImage;\r\n      eventImageElem.alt = `${eventName} Image`;\r\n      eventImageElem.style.width = \"100%\"; \r\n      eventImageElem.style.borderRadius = \"50px 0px 50px 0px\"; \r\n      eventImageElem.style.position = \"relative\";\r\n      eventImageElem.style.zIndex = \"0\";\r\n      eventCard.appendChild(eventImageElem);\r\n\r\n      const eventNameElem = document.createElement(\"h3\");\r\n      eventNameElem.textContent = eventName;\r\n      eventNameElem.style.color = \"#DC56C5\"; \r\n      eventCard.appendChild(eventNameElem);\r\n\r\n      const eventDateElem = document.createElement(\"p\");\r\n      eventDateElem.textContent = `${eventDate}`;\r\n      eventCard.appendChild(eventDateElem);\r\n\r\n      const eventLocationElem = document.createElement(\"p\");\r\n\r\n      // Creăm un container pentru imaginea vectorului și locație\r\n      const locationContainer = document.createElement(\"span\");\r\n      locationContainer.style.display = \"flex\";\r\n      locationContainer.style.alignItems = \"center\";\r\n\r\n      // Adăugăm imaginea vectorului pe aceeași linie cu locația\r\n      const vectorImg = document.createElement(\"img\");\r\n      vectorImg.src = \"../images/Vector.png\"; \r\n      vectorImg.alt = \"Vector Image\";\r\n      vectorImg.style.width = \"7px\"; \r\n      vectorImg.style.height = \"10px\"; \r\n      vectorImg.style.marginRight = \"7px\"; \r\n\r\n      // Adaugare la span\r\n      locationContainer.appendChild(vectorImg);\r\n      locationContainer.appendChild(document.createTextNode(eventLocation));\r\n      eventLocationElem.appendChild(locationContainer);\r\n      eventCard.appendChild(eventLocationElem);\r\n\r\n      // const eventUrlElem = document.createElement(\"a\");\r\n      // eventUrlElem.href = eventUrl;\r\n      // eventUrlElem.textContent = \"View Event\";\r\n      // eventUrlElem.target = \"_blank\";\r\n      // eventCard.appendChild(eventUrlElem);\r\n\r\n      eventContainer.appendChild(eventCard);\r\n      console.log(\"Event card created for event:\", eventName); \r\n    });\r\n  }\r\n\r\nfunction createPagination(totalPages, currentPage, searchTerm = \"\") {\r\n  // Limitează numărul total de pagini la 30\r\n  totalPages = Math.min(totalPages, 30);\r\n\r\n  if (totalPages <= 1) return;\r\n\r\n  // Create the previous page button\r\n  if (currentPage > 1) {\r\n    const prevButton = document.createElement(\"button\");\r\n    prevButton.textContent = \"Previous\";\r\n    prevButton.addEventListener(\"click\", function () {\r\n      fetchEvents(serverUrl, eventsPerPage, currentPage - 1, searchTerm);\r\n    });\r\n    paginationContainer.appendChild(prevButton);\r\n  }\r\n\r\n  // Create page buttons with ellipses\r\n  for (let i = 1; i <= totalPages; i++) {\r\n    if (\r\n      i === 1 ||\r\n      i === totalPages ||\r\n      (i >= currentPage - 2 && i <= currentPage + 2)\r\n    ) {\r\n      const pageButton = document.createElement(\"button\");\r\n      pageButton.textContent = i;\r\n      if (i === currentPage) {\r\n        pageButton.style.fontWeight = \"bold\";\r\n      }\r\n      pageButton.addEventListener(\"click\", function () {\r\n        fetchEvents(serverUrl, eventsPerPage, i, searchTerm);\r\n      });\r\n      paginationContainer.appendChild(pageButton);\r\n    } else if (i === currentPage - 3 || i === currentPage + 3) {\r\n      const dots = document.createElement(\"span\");\r\n      dots.textContent = \"...\";\r\n      paginationContainer.appendChild(dots);\r\n    }\r\n  }\r\n\r\n  // Create the next page button\r\n  if (currentPage < totalPages) {\r\n    const nextButton = document.createElement(\"button\");\r\n    nextButton.textContent = \"Next\";\r\n    nextButton.addEventListener(\"click\", function () {\r\n      fetchEvents(serverUrl, eventsPerPage, currentPage + 1, searchTerm);\r\n    });\r\n    paginationContainer.appendChild(nextButton);\r\n  }\r\n}\r\n\r\n});\r\n"],"names":["document","addEventListener","serverUrl","searchButton","getElementById","searchInput","eventContainer","modalEventName","paginationContainer","span","getElementsByClassName","modal","currentPage","fetchEvents","url","size","page","searchTerm","paginatedUrl","console","log","fetch","then","response","ok","error","status","statusText","Error","json","data","_embedded","events","innerHTML","filter","isValidEvent","forEach","event","eventName","name","eventUrl","eventDate","dates","start","dateTime","Date","toLocaleDateString","eventLocation","venues","city","eventImage","images","eventCard","createElement","classList","add","dataset","style","backgroundColor","border","position","square","borderRadius","top","right","width","height","zIndex","appendChild","eventImageElem","src","alt","eventNameElem","textContent","color","eventDateElem","eventLocationElem","locationContainer","display","alignItems","vectorImg","marginRight","createTextNode","createPagination","totalPages","Math","min","prevButton","i","pageButton","fontWeight","dots","nextButton","ceil","totalElements","fontSize","flexDirection","justifyContent","catch","message","body","value","alert","target","closest","onclick","window"],"version":3,"file":"index.c981fa59.js.map"}